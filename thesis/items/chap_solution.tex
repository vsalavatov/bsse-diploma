\section{Презентация решения}

В данной главе дан высокоуровневый обзор реализованной библиотеки \code{multifs}\cite{gh-multifs}, а также обоснования принятых архитектурных решений.

\subsection{Архитектура библиотеки}
  Ввиду того, что одна из главных задач заключается в организации поддержки файловых хранилищ на платформе JS (browser), то есть в веб-браузерах, возникает вопрос, какие файловые хранилища вообще можно на этой платформе поддержать? Поскольку в современных веб-браузерах много внимания уделяется безопасности, в них отсутствует доступ к файловой системе операционной системы, на которой они запущены. Для сохранения данных между сеансами можно пользоваться свойством \code{localStorage}\cite{dev-mozilla-localstorage} --- оно позволяет сохранять данные в виде пар ключ-значение. Гипотетически можно эмулировать файловую систему через эту структуру данных. Однако объем \code{localStorage} часто ограничен веб-браузерами и невелик: например, веб-браузер Firefox версии 98.0 ограничивает объем \code{localStorage} примерно десятью мегабайтами памяти. Если представить, что мы пишем, скажем, онлайн-редактор документов в формате docx и pdf, поддерживающее к тому же картинки, то сохранить много документов в таком хранилище просто не выйдет.

  Необходим доступ к <<настоящему>> файловому хранилищу, и в таком случае можно предложить следующие альтернативы локальной файловой системе, доступные из веб-браузеров:
  \begin{itemize}
    \item облачные хранилища, предоставляющие HTTP REST\cite{rest} API интерфейс для доступа к данным (Google Drive, Yandex.Disk, Dropbox, Amazon S3, и т.д.);
    \item подключение к удаленным файловым системам посредством FTP\cite{ftp}, попытка реализации чего была предпринята в проекте kile\cite{gh-kile}, или другим протоколам передачи файлов (SFTP, WebDAV, и т.д.).
  \end{itemize}

  Поскольку целью работы является также создание как можно более гибкой библиотеки в плане расширения множества поддерживаемых файловых хранилищ, имеет смысл выяснение функциональности и особенностей, которые имеют современные файловые хранилища.

  \subsubsection{Обзор функциональности и особенностей файловых хранилищ}\label{filesystems-overview}
    Для изучения выбраны несколько наиболее популярных онлайн-сервисов для хранения данных с публичным API: Google Drive, Яндекс.Диск, Dropbox, Amazon S3. Здесь перечисляются наиболее интересная (по мнению автора) функциональность и особенности, которые могут пригодится при решении поставленной задачи, более подробная информация содержится в официальной документации сервисов.
    
    \paragraph{Google Drive\cite{gdrive-about-files}.} 
      Файлы и папки не отличаются с точки зрения представления (то есть всё является файлом), различаются полем MimeType (у папок он равен \code{application/vnd.google-apps.folder}). Каждый файл имеет уникальный идентификатор (ID), при этом не запрещается иметь несколько файлов с одинаковым именем в одной папке. Файлы могут помимо своего содержимого хранить произвольные свойства (пары ключ-значение), есть атрибуты времени создания, модификации и доступа, атрибуты прав доступа. Файлы могут принадлежать одному из трёх изолированных пространств (spaces): пространство диска (drive space) --- основное пространство, в котором пользователь хранит свои файлы; пространство приложения (app data folder space) --- пространство, доступное только приложению и не доступное пользователю; пространство фотографий (photos space). Среди методов доступны создание файлов, скачивание, загрузка (в том числе больших файлов по частям), копирование (не папок), получение и изменение метаданных отдельно от содержимого (можно таким образом перемещать файлы), получение списка файлов с указанием фильтров (например, по id родителя).

    \paragraph{Яндекс.Диск\cite{yadisk-docs}.} Строгая иерархия каталогов и файлов, имена файлов уникальны и чувствительны к регистру. Доступна папка приложения, однако здесь пользователь имеет к ней прямой доступ. Файлы могут хранить произвольные атрибуты (пары ключ-значение). Присутствуют аналогичные методы для выполнения операций, перечисленных выше. Стоит отметить, что загрузка файлов на сервер по частям недоступна, а также доступно копирование папок. Файлы имеют одного владельца, но можно делать файлы полностью публичными.

    \paragraph{Dropbox\cite{dropbox-docs}.} Иерархия папок и файлов, имеющих уникальный идентификатор. Можно адресовать узлы как по пути от корня, так и по идентификаторам. Имена не чувствительны к регистру. Есть папки приложений. Поддерживаются произвольные атрибуты (пары ключ-значение). Доступна аналогичная функциональность как и у Яндекс.Диска, но доступна загрузка по частям. Есть система контроля доступа к файлам с разной гранулярностью (пользователи и группы).

    \paragraph{Amazon S3\cite{amazon-s3-docs}.} Данные хранятся в объектах (objects), расположенных в контейнерах (buckets). Объекты представляют собой содержимое файла и метаданные. Формально контейнер является плоской структурой (т.е. он хранит все объекты без иерархии), но можно организовать иерархию файлов и папок на логическом уровне, используя разделители (\code{/}) и общие префиксы для файлов, находящихся в одной директории. Есть система управления доступом к объектам, загрузка по частям, версионирование, произвольные атрибуты, копирование и другие методы, перечисленные выше.

    \paragraph{} Отдельно стоит отметить, что файловые системы наиболее популярных операционных систем для персональных компьютеров (Windows --- NTFS, FAT; дистрибутивы Linux --- ext4, btrfs, другие; Mac OS X --- APFS, HFS+) тоже имеют свои особенности. Например, файловая система HFS+ по умолчанию настроена так, что имена не чувствительны к регистру. В Windows по умолчанию операции с файловой системой осуществляются в не чувствительном к регистру режиме\cite{windows-case-sensitivity}. В дистрибутивах Linux файловые системы чувствительны к регистру. Данную особенность нужно учитывать при разработке приложений для этих платформ.

  %subsubsection
  \subsubsection{Базовые интерфейсы виртуальной файловой системы}
    \todo{Еще про okio}
    Самое близкое к решению целевой задачи из уже существующего (в концептуальном смысле) --- это упомянутый в обзоре проект korio\cite{gh-korio}. В нем представлен базовый интерфейс виртуальной файловой системы как абстракции, которую реализуют доступные файловые хранилища на конечных платформах. Однако этот интерфейс сильно перегружен: например, там есть методы для наблюдения за событиями файловой системы на определенном файле, но такую функциональность поддерживают не все облачные хранилища (например, Яндекс.Диск не поддерживает), также некоторые абстрактные методы имеют базовые реализации, которые ничего не делают (например, метод \code{touch}). При попытке поддержать файловое хранилище, может возникнуть ситуация, когда реализация части функциональности не будет возможна ввиду отсутствия такой функциональности у целевого хранилища. В результате, когда пользователь-разработчик будет пытаться использовать определенную функциональность виртуальной файловой системы в общем модуле мультиплатформенного проекта, у него не будет уверенности, что она вообще реализована. Это является существенным недостатком, которого хочется избежать.

    Каких дополнительных свойств хочется добиться от конечной библиотеки: 
    \begin{itemize}
    \item базовый интерфейс виртуальной файловой системы дает гарантию поддержки минимального набора операций, с помощью которого можно выполнять любые базовые операции над файлами (создание, удаление файлов и папок; запись, чтение, перемещение, копирование файлов) --- это позволит быстро обеспечивать базовую поддержку любых хранилищ, которая нужна пользователю;
    \item поддержка особых возможностей обеспечивается через реализацию дополнительных интерфейсов-расширений виртуальной файловой системы.
    \end{itemize}
    Понятно, что для приложения может быть недостаточно лишь базовых операций для работы с файлами. Нужен инструмент для определения контракта по необходимой функциональности файловых хранилищ, которые будут использоваться на целевых платформах. Эту проблему можно решить на уровне типов языка Kotlin, об этом будет рассказано позже.

    Ввиду особенностей различных файловых хранилищ, перечисленных в разделе \ref{filesystems-overview}, предлагается отказаться от адресации узлов по полным путям и ввести на уровне типов отдельно папку и файл как узлы иерархии.

    \todo{что-то ещё?}
    \todo{про симлинки?}

    Перейдем к обзору реализованных интерфейсов, которые будут в основе поддержки любого файлового хранилища.
    
    \makefig{vfsnode-folder-file}{0.65\textwidth}{
      \label{fig:vfsnode-folder-file} Интерфейсы узлов виртуальной файловой системы.
    }
    На рисунке~\ref{fig:vfsnode-folder-file} изображена схема интерфейсов узлов виртуальной файловой системы (VFS). 
    
    \code{VFSNode} --- интерфейс, представляющий любой узел VFS,содержит имя, ссылку на родителя, который всегда является папкой, а также абсолютный путь до этого узла (на самом деле путь храниться в памяти не будет, а будет вычисляемым свойством\cite{kotlin-computed-property}).

    \code{Folder} --- интерфейс, представляющий папку VFS, содержит методы для получения дочерних узлов; создания папки или файла; удаления узла (флаг \code{recursively} нужен для определения поведения в случае удаления пустой и непустой папок). Функции-операторы \code{div} (\code{/}) и \code{mod} (\code{\%}) выступают в качестве методов для упрощения навигации по дереву виртуальной файловой системы. Решение ввести две функции для навигации связано с желанием обеспечить автоматический вывод типа: например, тип выражения \code{folder / "subfolder"} является \code{Folder}, а значит можно писать цепочки вида \code{folder / "subfolder"\ / "a"\ / "b"\ / "c"}, что визуально выглядит как стандартное представление пути в Linux-системах. Получить файл можно, написав выражение вида \code{folder / "subfolder"\ \% "file.txt"}.
    
    \code{File} --- интерфейс, представляющий файл VFS, содержит методы для удаления, получения размера в байтах, записи и чтения содержимого целиком как массивов байт.

    \makefig{vfs}{0.8\textwidth}{
      \label{fig:vfs} Интерфейс виртуальной файловой системы.
    }
    На рисунке~\ref{fig:vfs} представлен интерфейс непосредственно виртуальной файловой системы. Сразу отметим, что это обобщенный (generic) интерфейс, параметризованный типами файла и папки. Такая запись позволяет включить изначально несвязанные классы, реализующие представленные интерфейсы узлов ВФС, в тип самой ВФС. Это позволит налагать требования на функциональность этих классов на уровне типов. \code{VFS} имеет свойство \code{root} --- корень файловой системы, а также методы для копирования и перемещения файлов. Метод \code{representPath} определен для того, чтобы была возможность представлять абсолютные пути в родном для файловой системы виде.

    Все перечисленные методы (кроме \code{representPath}) являются останавливаемыми \cite{kotlin-lang-coro-ru} (suspendable), то есть помечены модификатором \code{suspend}. Необходимость этого заключается в том, что все операции непосредственно связаны с тем или иным вводом-выводом (от просто системного вызова до отправки HTTP запроса), а значит существенную часть их исполнения может занимать ожидание. Чтобы эффективнее использовать процессорное время, язык предоставляет механизм кооперативной многозадачности в виде сопрограмм (coroutines), который в данном случае отражен в модификаторе \code{suspend}. 

    Заметим, что методы \code{copy} и \code{move} принимают базовые типы \code{File} и \code{Folder}, а возвращают \code{FileClass} --- то есть тип файла, который на самом деле предоставляет виртуальная файловая система, реализующая интерфейс. Может возникнуть вопрос, а не должны ли эти методы принимать файлы и папки типов-параметров \code{FileClass} и \code{FolderClass}, то есть принадлежащих исключительно виртуальной файловой системе, с которой мы работаем. Одна из ключевых концепций использования библиотеки заключается в том, приложение, которое мы пишем, может предоставлять пользователю выбор из нескольких хранилищ для использования. Это означает, что код в общем модуле должен уметь работать с ВФС разных типов (скажем, \code{VFS<LocalFile, LocalFolder>} и \code{VFS<YaDiskFile, YaDiskFolder>}). Чтобы это было возможно, нужна ковариантность\cite{kotlin-generics} типовых параметров интерфейса \code{VFS}. То есть наш код с логикой приложения может принимать аргумент типа \code{VFS<out File, out Folder>}, подтипами которого являются перечисленные типы выше. Однако это не позволяет в аргументах методов интерфейса \code{VFS} принимать аргументы, которые \'{у}же (в смысле общности типа), чем верхняя граница, то есть \code{File} и \code{Folder}. Исходя из данного обстоятельства, можно определить семантику методов \code{copy} и \code{move} следующим образом. Методы принимают в качестве аргументов файлы и папки любых типов-наследников \code{File} и \code{Folder}, но выполняется проверка времени исполнения соответствия фактического типа папки данной \code{VFS} (при несоответствии бросается исключение); если фактический тип файла соотвествует данной \code{VFS}, то операции эффективны с точки зрения использования возможностей файлового хранилища, иначе операция может быть неэффективной по ресурсам (например, это может быть чтение содержимого целиком в память и далее запись в целевой файл). Семантика поведения в случае несоответствия файла \code{VFS}, вероятно, спорна и может измениться, если библиотека получит развитие.
    
%    Чтобы разобраться, рассмотрим небольшой пример кода гипотетического редактора фотографий, который мы можем написать в общем модуле мультиплатформенного проекта:
%
%    \begin{minted}{kotlin}
%suspend fun moveResultImage(
%  // VFS для хранения промежуточных файлов приложения
%  internal: VFS<out File, out Folder>, 
%  // галерея пользователя (папка "картинки")
%  userGallery: VFS<out File, out Folder>, 
%  filename: String // имя файла
%) {
%  val image = internal.root / "result-images" % filename
%  // перемещаем файл из папки приложения в папку пользователя
%  userGallery.move(image, userGallery.root) 
%}
%    \end{minted}
%
%    Типовой аргумент \code{out File} по сути обозначает, что мы ожидаем, что первый типовой аргумент должен реализовывать интерфейс \code{File}. Аналогично с \code{Folder}. Почему запись именно такая, обсуждается в следующем разделе.
%
%    Допустим, мы хотим, чтобы этот код работал в веб-браузере (скажем, \code{internal} будет связан с \code{window.localStorage}, \code{userGallery} --- с папкой фотографий пользователя в Яндекс.Диске или другом облачном хранилище), а также на смартфонах под управлением ОС Android (\code{internal} --- папка для кэша приложения, \code{userGallery} --- папка с фотографиями пользователя). В этом случае в веб-браузере данные \code{VFS} будут различные фактические типы, а 

  % subsubsection

  \subsubsection{Расширения}
    Расширения представляют из себя дополнительные интерфейсы, которые могут реализовывать виртуальные файловые системы.
    \makefig{streamingio}{0.4\textwidth}{
      \label{fig:streamingio} Интерфейс расширения функциональности файла, обеспечивающий потоковое чтение и запись содерижмого.
    }

    В качестве демонстрации было реализовано одно расширение, изображенное на рисунке~\ref{fig:streamingio}. \code{ByteReadChannel} --- это интерфейс из библиотеки Ktor (см. раздел \ref{dependencies-ktor}), который предоставляет методы потоковой обработки байт.
    
    Интерес представляет то, как работать с этими расширениями в общем коде. Kotlin позволяет задавать несколько верхних границ типовому параметру:
    \begin{minted}{kotlin}
suspend fun <F> videoPlayer(fs: VFS<out F, out Folder>)
        where F : File, F : StreamingIO {
  @Suppress("UNCHECKED_CAST")
  val movie = (fs.root / "movies" % "matrix.mp4") as F
  val movieDataStream = movie.readStream()
  playMovie(movieDataStream)
}
    \end{minted}
    Как видно из примера, достаточно перечислить требуемую функциональность в блоке \code{where}. Так как методы для навигации возвращают лишь базовые типы \code{File} и \code{Folder}, приходится делать явное преобразование типов. Но заметим, что в данном случае оно безопасно, поскольку файл \code{movie} получен путем навигации по дереву \code{fs}, а в типе \code{fs} заявлен тип файла \code{F}. Была осуществлена попытка реализовать навигацию, позволяющую обойтись без приведения типа, но она окончилась неудачей.

    Из неудобств данной записи можно отметить также то, что нельзя завести синоним типа (\code{typealias}), сочетающий в себе несколько верхних границ. Kotlin позволяет заводить синоним типа вида 
    \begin{minted}{kotlin}
typealias Storage = VFS<out File, out Folder>,
    \end{minted}
    но на текущий момент язык не позволяет записи вида 
    \begin{minted}{kotlin}
typealias Storage = VFS<out (File & StreamingIO), out Folder>,
    \end{minted}
    однако авторы языка рассматривают\cite{kotlin-intersection-types} добавление такой возможности.
  % subsubsection

  \subsubsection{Инварианты и гарантии}
    \todo{ссылка на родителя}  

    \todo{exception'ы и их ловля, метки}

    \todo{если папка не пуста, удалить ее нельзя без recursively}
    
    \todo{нет ограничения на имена файлов папок и тд, за этим должен следить пользователь-разраб}
  % subsubsection

  \subsubsection{Преимущества и недостатки выбранного подхода}
    \todo{удобная и понятная навигация с выводом типов}

    \todo{интерфейс предоставляет только ту функциональность, которая на самом деле доступна}

    \todo{довольно емкий платформо-специфичный код (определение бекендов)}

    \todo{не очень удобно записывать ограничения на типы, но вот если котлин сделает типы-пересечения, то станет норм}

    \todo{без тайпкастов не обойтись}
    
  % subsubsection

% subsection

\subsection{Хранилища, поддержанные библиотекой}

  \subsubsection{\code{SystemFS}}
    \makefig{systemfs-detailed}{\textwidth}{
      \label{fig:systemfs-detailed}
          \todo{SystemFS}.
    }
    Ссылаемся на график~\ref{fig:systemfs-detailed}.
    \todo{обертка над \code{java.nio.Path}}
  % subsubsection
  \subsubsection{\code{GoogleDriveFS}}
    \todo{GoogleDriveAPI и сам GoogleDriveFS в общем коде, на платформах только Authorizer'ы}
    \makefig{gdrive-multiplatform-arch}{\textwidth}{
      \label{fig:gdrive-multiplatform-arch}
          Архитектура реализации поддержки файлового хранилища Google Drive.
    }
    Ссылаемся на график~\ref{fig:gdrive-multiplatform-arch}.
  % subsubsection
  \subsubsection{\code{SqliteFS}}
    \todo{адаптер к Sqlite на Андроиде}
  % subsubsection

% subsection

\subsection{Используемые зависимости}

  \subsubsection{Ktor}\label{dependencies-ktor}
    \todo{нужен как мультиплатформенный HTTP клиент + из IO взял ByteChannel}
  % subsubsection

  \subsubsection{Зависимости на платформе Android}
    \begin{itemize}
      \item activity-ktx
        \todo{предоставляет расширения java классов для языка котлин??}
      \item play-services-auth
        \todo{тут лежит SignInIntent чтобы авторизацию производить}
    \end{itemize}
  % subsubsection

% subsection

% section
