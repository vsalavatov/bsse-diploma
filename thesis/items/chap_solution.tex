\section{Презентация решения}

В данной главе дан высокоуровневый обзор реализованной библиотеки \code{multifs}\cite{gh-multifs}, а также обоснования принятых архитектурных решений.

\subsection{Архитектура библиотеки}
  Ввиду того, что одна из главных задач заключается в организации поддержки файловых хранилищ на платформе JS (browser), то есть в веб-браузерах, возникает вопрос, какие файловые хранилища вообще можно на этой платформе поддержать? Поскольку в современных веб-браузерах много внимания уделяется безопасности, в них отсутствует доступ к файловой системе операционной системы, на которой они запущены. Для сохранения данных между сеансами можно пользоваться свойством \code{localStorage}\cite{dev-mozilla-localstorage} --- оно позволяет сохранять данные в виде пар ключ-значение. Гипотетически можно эмулировать файловую систему через эту структуру данных. Однако объем \code{localStorage} часто ограничен веб-браузерами и невелик: например, веб-браузер Firefox версии 98.0 ограничивает объем \code{localStorage} примерно десятью мегабайтами памяти. Если представить, что мы пишем, скажем, онлайн-редактор документов в формате docx и pdf, поддерживающее к тому же картинки, то сохранить много документов в таком хранилище просто не выйдет.

  Необходим доступ к <<настоящему>> файловому хранилищу, и в таком случае можно предложить следующие альтернативы локальной файловой системе, доступные из веб-браузеров:
  \begin{itemize}
    \item облачные хранилища, предоставляющие HTTP REST\cite{rest} API интерфейс для доступа к данным (Google Drive, Yandex.Disk, Dropbox, Amazon S3, и т.д.);
    \item подключение к удаленным файловым системам посредством FTP\cite{ftp}, попытка реализации чего была предпринята в проекте kile\cite{gh-kile}, или другим протоколам передачи файлов (SFTP, WebDAV, и т.д.).
  \end{itemize}

  Поскольку целью работы является также создание как можно более гибкой библиотеки в плане расширения множества поддерживаемых файловых хранилищ, имеет смысл выяснение функциональности и особенностей, которые имеют современные файловые хранилища.

  \subsubsection{Обзор функциональности и особенностей файловых хранилищ}\label{filesystems-overview}
    Для изучения выбраны несколько наиболее популярных онлайн-сервисов для хранения данных с публичным API: Google Drive, Яндекс.Диск, Dropbox, Amazon S3. Здесь перечисляются наиболее интересная (по мнению автора) функциональность и особенности, которые могут пригодится при решении поставленной задачи, более подробная информация содержится в официальной документации сервисов.
    
    \paragraph{Google Drive\cite{gdrive-about-files}.} 
      Файлы и папки не отличаются с точки зрения представления (то есть всё является файлом), различаются полем MimeType (у папок он равен \code{application/vnd.google-apps.folder}). Каждый файл имеет уникальный идентификатор (ID), при этом не запрещается иметь несколько файлов с одинаковым именем в одной папке. Файлы могут помимо своего содержимого хранить произвольные свойства (пары ключ-значение), есть атрибуты времени создания, модификации и доступа, атрибуты прав доступа. Файлы могут принадлежать одному из трёх изолированных пространств (spaces): пространство диска (drive space) --- основное пространство, в котором пользователь хранит свои файлы; пространство приложения (app data folder space) --- пространство, доступное только приложению и недоступное пользователю; пространство фотографий (photos space). Среди методов доступны создание файлов, скачивание, загрузка (в том числе больших файлов по частям), копирование (не папок), получение и изменение метаданных отдельно от содержимого (можно таким образом перемещать файлы), получение списка файлов с указанием фильтров (например, по id родителя).

    \paragraph{Яндекс.Диск\cite{yadisk-docs}.} Строгая иерархия каталогов и файлов, имена файлов уникальны и чувствительны к регистру. Доступна папка приложения, однако здесь пользователь имеет к ней прямой доступ. Файлы могут хранить произвольные атрибуты (пары ключ-значение). Присутствуют аналогичные методы для выполнения операций, перечисленных выше. Стоит отметить, что загрузка файлов на сервер по частям недоступна, а также доступно копирование папок. Файлы имеют одного владельца, но можно делать файлы полностью публичными.

    \paragraph{Dropbox\cite{dropbox-docs}.} Иерархия папок и файлов, имеющих уникальный идентификатор. Можно адресовать узлы как по пути от корня, так и по идентификаторам. Имена не чувствительны к регистру. Есть папки приложений. Поддерживаются произвольные атрибуты (пары ключ-значение). Доступна аналогичная функциональность как и у Яндекс.Диска, но доступна загрузка по частям. Есть система контроля доступа к файлам с разной гранулярностью (пользователи и группы).

    \paragraph{Amazon S3\cite{amazon-s3-docs}.} Данные хранятся в объектах (objects), расположенных в контейнерах (buckets). Объекты представляют собой содержимое файла и метаданные. Формально контейнер является плоской структурой (т.е. он хранит все объекты без иерархии), но можно организовать иерархию файлов и папок на логическом уровне, используя разделители (\code{/}) и общие префиксы для файлов, находящихся в одной директории. Есть система управления доступом к объектам, загрузка по частям, версионирование, произвольные атрибуты, копирование и другие методы, перечисленные выше.

    \paragraph{} Отдельно стоит отметить, что файловые системы наиболее популярных операционных систем для персональных компьютеров (Windows --- NTFS, FAT; дистрибутивы Linux --- ext4, btrfs, другие; Mac OS X --- APFS, HFS+) тоже имеют свои особенности. Например, файловая система HFS+ по умолчанию настроена так, что имена не чувствительны к регистру. В Windows по умолчанию операции с файловой системой осуществляются в не чувствительном к регистру режиме\cite{windows-case-sensitivity}. В дистрибутивах Linux файловые системы чувствительны к регистру. Данную особенность нужно учитывать при разработке приложений для этих платформ.

  %subsubsection
  \subsubsection{Базовые интерфейсы виртуальной файловой системы}
    \todo{Еще про okio}
    Самое близкое к решению целевой задачи из уже существующего (в концептуальном смысле) --- это упомянутый в обзоре проект korio\cite{gh-korio}. В нем представлен базовый интерфейс виртуальной файловой системы как абстракции, которую реализуют доступные файловые хранилища на конечных платформах. Однако этот интерфейс сильно перегружен: например, там есть методы для наблюдения за событиями файловой системы на определенном файле, но такую функциональность поддерживают не все облачные хранилища (например, Яндекс.Диск не поддерживает), также некоторые абстрактные методы имеют базовые реализации, которые ничего не делают (например, метод \code{touch}). При попытке поддержать файловое хранилище, может возникнуть ситуация, когда реализация части функциональности не будет возможна ввиду отсутствия такой функциональности у целевого хранилища. В результате, когда пользователь-разработчик будет пытаться использовать определенную функциональность виртуальной файловой системы в общем модуле мультиплатформенного проекта, у него не будет уверенности, что она вообще реализована. Это является существенным недостатком, которого хочется избежать.

    Каких дополнительных свойств хочется добиться от конечной библиотеки: 
    \begin{itemize}
    \item базовый интерфейс виртуальной файловой системы дает гарантию поддержки минимального набора операций, с помощью которого можно выполнять любые базовые операции над файлами (создание, удаление файлов и папок; запись, чтение, перемещение, копирование файлов) --- это позволит быстро обеспечивать базовую поддержку любых хранилищ, которая нужна пользователю;
    \item поддержка особых возможностей обеспечивается через реализацию дополнительных интерфейсов-расширений виртуальной файловой системы.
    \end{itemize}
    Понятно, что для приложения может быть недостаточно лишь базовых операций для работы с файлами. Нужен инструмент для определения контракта по необходимой функциональности файловых хранилищ, которые будут использоваться на целевых платформах. Эту проблему можно решить на уровне типов языка Kotlin, об этом будет рассказано позже.

    Ввиду особенностей различных файловых хранилищ, перечисленных в разделе \ref{filesystems-overview}, предлагается отказаться от адресации узлов по полным путям и ввести на уровне типов отдельно папку и файл как узлы иерархии.

    \todo{что-то ещё?}
    \todo{про симлинки?}

    Перейдем к обзору реализованных интерфейсов, которые будут в основе поддержки любого файлового хранилища.
    
    \makefig{vfsnode-folder-file}{0.65\textwidth}{
      \label{fig:vfsnode-folder-file} Интерфейсы узлов виртуальной файловой системы.
    }
    На рисунке~\ref{fig:vfsnode-folder-file} изображена схема интерфейсов узлов виртуальной файловой системы (VFS). 
    
    \code{VFSNode} --- интерфейс, представляющий любой узел VFS,содержит имя, ссылку на родителя, который всегда является папкой, а также абсолютный путь до этого узла (на самом деле путь храниться в памяти не будет, а будет вычисляемым свойством\cite{kotlin-computed-property}).

    \code{Folder} --- интерфейс, представляющий папку VFS, содержит методы для получения дочерних узлов; создания папки или файла; удаления узла (флаг \code{recursively} нужен для определения поведения в случае удаления пустой и непустой папок). Функции-операторы \code{div} (\code{/}) и \code{mod} (\code{\%}) выступают в качестве методов для упрощения навигации по дереву виртуальной файловой системы. Решение ввести две функции для навигации связано с желанием обеспечить автоматический вывод типа: например, тип выражения \code{folder / "subfolder"} является \code{Folder}, а значит можно писать цепочки вида \code{folder / "subfolder"\ / "a"\ / "b"\ / "c"}, что визуально выглядит как стандартное представление пути в Linux-системах. Получить файл можно, написав выражение вида \code{folder / "subfolder"\ \% "file.txt"}.
    
    \code{File} --- интерфейс, представляющий файл VFS, содержит методы для удаления, получения размера в байтах, записи и чтения содержимого целиком как массивов байт.

    \makefig{vfs}{0.8\textwidth}{
      \label{fig:vfs} Интерфейс виртуальной файловой системы.
    }
    На рисунке~\ref{fig:vfs} представлен интерфейс непосредственно виртуальной файловой системы. Сразу отметим, что это обобщенный (generic) интерфейс, параметризованный типами файла и папки. Такая запись позволяет включить изначально несвязанные классы, реализующие представленные интерфейсы узлов ВФС, в тип самой ВФС. Это позволит налагать требования на функциональность этих классов на уровне типов. \code{VFS} имеет свойство \code{root} --- корень файловой системы, а также методы для копирования и перемещения файлов. Метод \code{representPath} определен для того, чтобы была возможность представлять абсолютные пути в родном для файловой системы виде.

    Все перечисленные методы (кроме \code{representPath}) являются останавливаемыми \cite{kotlin-lang-coro-ru} (suspendable), то есть помечены модификатором \code{suspend}. Необходимость этого заключается в том, что все операции непосредственно связаны с тем или иным вводом-выводом (от просто системного вызова до отправки HTTP-запроса), а значит существенную часть их исполнения может занимать ожидание. Чтобы эффективнее использовать процессорное время, язык предоставляет механизм кооперативной многозадачности в виде сопрограмм (coroutines), который в данном случае отражен в модификаторе \code{suspend}. 

    Заметим, что методы \code{copy} и \code{move} принимают базовые типы \code{File} и \code{Folder}, а возвращают \code{FileClass} --- то есть тип файла, который на самом деле предоставляет виртуальная файловая система, реализующая интерфейс. Может возникнуть вопрос, а не должны ли эти методы принимать файлы и папки типов-параметров \code{FileClass} и \code{FolderClass}, то есть принадлежащих исключительно виртуальной файловой системе, с которой мы работаем. Одна из ключевых концепций использования библиотеки заключается в том, что приложение, которое мы пишем, может предоставлять пользователю выбор из нескольких хранилищ для использования. Это означает, что код в общем модуле должен уметь работать с ВФС разных типов (скажем, \code{VFS<LocalFile, LocalFolder>} и \code{VFS<YaDiskFile, YaDiskFolder>}). Чтобы это было возможно, нужна ковариантность\cite{kotlin-generics} типовых параметров интерфейса \code{VFS}. То есть наш код с логикой приложения может принимать аргумент типа \code{VFS<out File, out Folder>}, подтипами которого являются перечисленные типы выше. Однако это не позволяет в методах интерфейса \code{VFS} принимать аргументы, которые \'{у}же (в смысле общности типа), чем верхняя граница, то есть \code{File} и \code{Folder}. Исходя из данного обстоятельства, можно определить семантику методов \code{copy} и \code{move} следующим образом. Методы принимают в качестве аргументов файлы и папки любых типов-наследников \code{File} и \code{Folder}, но выполняется проверка времени исполнения соответствия фактического типа папки данной \code{VFS} (при несоответствии бросается исключение); если фактический тип файла соотвествует данной \code{VFS}, то операции эффективны с точки зрения использования возможностей файлового хранилища, иначе операция может быть неэффективной по ресурсам (например, это может быть чтение содержимого целиком в память и далее запись в целевой файл). Семантика поведения в случае несоответствия файла \code{VFS}, вероятно, спорна и может измениться, если библиотека получит развитие.
    
%    Чтобы разобраться, рассмотрим небольшой пример кода гипотетического редактора фотографий, который мы можем написать в общем модуле мультиплатформенного проекта:
%
%    \begin{minted}{kotlin}
%suspend fun moveResultImage(
%  // VFS для хранения промежуточных файлов приложения
%  internal: VFS<out File, out Folder>, 
%  // галерея пользователя (папка "картинки")
%  userGallery: VFS<out File, out Folder>, 
%  filename: String // имя файла
%) {
%  val image = internal.root / "result-images" % filename
%  // перемещаем файл из папки приложения в папку пользователя
%  userGallery.move(image, userGallery.root) 
%}
%    \end{minted}
%
%    Типовой аргумент \code{out File} по сути обозначает, что мы ожидаем, что первый типовой аргумент должен реализовывать интерфейс \code{File}. Аналогично с \code{Folder}. Почему запись именно такая, обсуждается в следующем разделе.
%
%    Допустим, мы хотим, чтобы этот код работал в веб-браузере (скажем, \code{internal} будет связан с \code{window.localStorage}, \code{userGallery} --- с папкой фотографий пользователя в Яндекс.Диске или другом облачном хранилище), а также на смартфонах под управлением ОС Android (\code{internal} --- папка для кэша приложения, \code{userGallery} --- папка с фотографиями пользователя). В этом случае в веб-браузере данные \code{VFS} будут различные фактические типы, а 

  % subsubsection

  \subsubsection{Расширения}
    Расширения представляют из себя дополнительные интерфейсы, которые могут реализовывать виртуальные файловые системы.
    \makefig{streamingio}{0.4\textwidth}{
      \label{fig:streamingio} Интерфейс расширения функциональности файла, обеспечивающий потоковое чтение и запись содержимого.
    }

    В качестве демонстрации было реализовано одно расширение, представленное на рисунке~\ref{fig:streamingio}. \code{ByteReadChannel} --- это интерфейс из библиотеки Ktor (см. раздел \ref{dependencies-ktor}), который предоставляет методы потоковой обработки байт. Оба метода помечены модификатором \code{suspend}.
    
    Интерес представляет то, как работать с этими расширениями в общем коде. Kotlin позволяет задавать несколько верхних границ типовому параметру:
    \begin{minted}{kotlin}
suspend fun <F> videoPlayer(fs: VFS<out F, out Folder>)
        where F : File, F : StreamingIO {
  @Suppress("UNCHECKED_CAST")
  val movie = (fs.root / "movies" % "matrix.mp4") as F
  val movieDataStream = movie.readStream()
  playMovie(movieDataStream)
}
    \end{minted}
    Как видно из примера, достаточно перечислить требуемую функциональность в блоке \code{where}. Так как методы для навигации возвращают лишь базовые типы \code{File} и \code{Folder}, приходится делать явное преобразование типов. Но заметим, что в данном случае оно безопасно, поскольку файл \code{movie} получен путем навигации по дереву \code{fs}, а в типе \code{fs} заявлен тип файла \code{F}. Была осуществлена попытка реализовать навигацию, позволяющую обойтись без приведения типа, но она окончилась неудачей.

    Из неудобств данной записи можно отметить то, что нельзя завести синоним типа (\code{typealias}), сочетающий в себе несколько верхних границ. Kotlin позволяет заводить синоним типа вида 
    \begin{minted}{kotlin}
typealias Storage = VFS<out File, out Folder>,
    \end{minted}
    но на текущий момент язык не позволяет записи вида 
    \begin{minted}{kotlin}
typealias Storage = VFS<out (File & StreamingIO), out Folder>,
    \end{minted}
    однако авторы языка рассматривают\cite{kotlin-intersection-types} добавление такой возможности.

    Среди базовых расширений, которые можно было бы дополнительно реализовать можно назвать следующие: поддержка меток времени создания, доступа и модификации файла, прав доступа на чтение и запись; поддержка атомарных операций; возможность управлять произвольными атрибутами (пары ключ-значение).
  % subsubsection

  \subsubsection{Инварианты и гарантии}
    \begin{itemize}
    \item Свойство \code{parent} интерфейса \code{VFSNode} указывает на родительскую папку для данного узла. Для корневой папки это свойство ссылается на сам корень. Для удобства разработки для интерфейса \code{Folder} добавлено булево свойство-расширение \code{isRoot}.
    
    \item Удаление папки без явно установленного флага \code{recursively} возможно только в случае, если папка пуста. Иначе бросается исключение, помеченное \todo{VFSFolderNotEmptyException???? пока никак не помеченное}.

    \item Библиотека не накладывает никаких ограничений на имена файлов и папок. Пользователь библиотеки должен самостоятельно проверить совместимость используемых файловых хранилищ с логикой приложения и при необходимости ограничить конечного пользователя в именовании файлов и папок.

    \item Методы для навигации проверяют существование файла или папки: если узла не существует, бросается исключение, помеченное\\ \code{VFSFileNotFoundException} или \code{VFSFolderNotFoundException}.

    \item Классы файлов и папок переопределяют методы \code{equals} и \code{hashcode} в соответствии с семантикой ВФС.

    \item Методы \code{copy} и \code{move} принимают любые файлы и папки, однако фактический тип папки должен соответствовать виртуальной файловой системе. Гарантируется эффективная реализация этих методов, только если фактический тип файла соотвествует ВФС. В противном случае не дается гарантий на эффективность (возможная реализация --- чтение файла целиком в память и его запись в целевой файл). 

    Заметим, что для сохранения гарантии достаточно обеспечить, чтобы операции над узлами ВФС не покидали ее пределов.

    \item Все методы ВФС или её узлов могут бросить исключения только типов-наследников \code{VFSException}. Вместе с сообщением об ошибке передается также исключение-причина в поле \code{cause}, если оно было брошено внутри реализации ВФС.
    Для возможности более гранулярной ловли исключений добавлены интерфейсы-маркеры: \code{VFSNodeNotFoundException} с двумя наследниками для файла и папки и аналогичные маркеры \code{VFSNodeExistsException}.

    \end{itemize}
  % subsubsection

  \subsubsection{Преимущества и недостатки выбранного подхода}
    Чего удалось добиться представленной архитектурой:
    \begin{itemize}
      \item удобная и понятная навигация с выводом типов;
      \item ВФС предоставляет только ту функциональность, которая на самом деле доступна;
      \item есть возможность расширения функциональности ВФС и наложения требований на их наличие на уровне типов;
      \item базовые интерфейсы просты и лаконичны, их сравнительно легко реализовать для нового файлового хранилища;
      \item платформо-специфичный код приложений получается очень ёмким (будет показано в примерах позже).
    \end{itemize}
    Из недостатков можно отметить следующие:
    \begin{itemize}
      \item при работе с расширениями приходится использовать обобщенные функции, а также каждый раз указывать типовые ограничения;
      \item также при работе с расширениями приходится явно приводить типы конечных файлов при навигации, хоть это и безопасно;
      \item неочевидная семантика методов \code{copy} и \code{move}, если использовать их на файлах, не относящихся к ВФС.
    \end{itemize}
  % subsubsection

% subsection

\subsection{Файловые хранилища, поддержанные библиотекой}
  В этом разделе рассказывается о поддержанных хранилищах и их возможностях. Детали реализации описаны в разделе~\ref{solution-details}.

  \subsubsection{\code{SystemFS}}
    \code{SystemFS} --- это ВФС, которая предоставляет доступ к локальной файловой системе посредством функциональности \code{java.nio.Path}, доступна на платформах JVM и Android.
    \makefig{systemfs-detailed}{\textwidth}{
      \label{fig:systemfs-detailed}
          Диаграмма классов \code{SystemFS}.
    }

    На рисунке~\ref{fig:systemfs-detailed} изображена схема наследования классов данной ВФС. Узел \code{SystemFSNode} содержит свойство \code{nioPath}, представляющего путь в локальной файловой системе до этого узла. Реализация методов узлов по сути состоит из вызова соответствующего метода \code{nioPath} и обработки ошибок. \code{java.nio.Path} предоставляет функциональность для потокового чтения и записи, так что реализация расширения \code{StreamingIO} тоже получилась очень простой.

    Конструктор класса \code{SystemFS} принимает путь до папки, которая будет корнем ВФС, по умолчанию установлено значение пути до текущей рабочей директории. Этот механизм позволяет ограничивать операции над ВФС в пределах одной директории настоящей файловой системы.
    
  % subsubsection
  \subsubsection{\code{GoogleDriveFS}}
    \code{GoogleDriveFS} --- это ВФС, которая предоставляет доступ к содержимому Google Drive пользователя. Коммуникация с сервисом осуществляется через REST HTTP API с помощью библиотеки Ktor. Доступна на всех платформах.

    Для использования необходимо зарегистрировать приложение в консоли Google Cloud\cite{google-cloud}, настроить его, добавив в список API доступ к Google Drive, и получить учетные данные (идентификатор приложения и секретный ключ).

    \makefig{gdrive-multiplatform-arch}{1.02\textwidth}{
      \label{fig:gdrive-multiplatform-arch}
          Архитектура реализации поддержки файлового хранилища Google Drive.
    }

    На рисунке~\ref{fig:gdrive-multiplatform-arch} изображена архитектура поддержки этого файлового хранилища. Видим, что в данном случае код имеет платформо-специфичные компоненты (\code{GoogleAuthorizationRequester} для платформ JVM, Android и JS (browser)). В общем модуле расположена вся основная логика для обеспечения работы ВФС: это сами классы ВФС и ее узлов (с аналогичной схемой наследования как на рисунке~\ref{fig:systemfs-detailed}), которым для работы нужен экземпляр \code{GoogleDriveAPI} --- это по сути набор методов для совершения HTTP-запросов в сервис Google Drive. Для совершения HTTP-запросов используется мультиплатформенная библиотека Ktor. Чтобы совершать HTTP-запросы от имени пользователя, необходимо получить ключ доступа (access token) к пространству пользователя, для этого необходимо пройти процедуру авторизации по протоколу OAuth 2.0\cite{google-oauth-2.0}. Для этого нужно каким-то образом отправить пользователя в сервис авторизации Google, где он подтвердит выдачу авторизации нашему приложению. На разных платформах это делается по-разному.
    \begin{itemize}
      \item Если наше приложение работает в веб-браузере, то можно воспользоваться средствами JavaScript-библиотеки Google Platform Library, которая сама проводит пользователя через весь процесс, открывая дополнительную вкладку в браузере, и возвращает готовые ключи в JavaScript-объекте.
      \item Если наше приложение работает на платформе JVM (на персональном компьютере), то один из вариантов провести авторизацию работает следующим образом. Приложение запускает HTTP-сервер, далее открывает страницу в браузере со специальной ссылкой на сервис авторизации Google, куда добавлена информация об адресе созданного HTTP-сервера. Когда пользователь подтверждает авторизацию доступа приложению, страница отправляет HTTP-запрос с кодом авторизации по указанному адресу, нам остается его получить и обменять на ключи доступа.
      \item Если наше приложение работает на устройстве под управлением Android, то можно воспользоваться библиотекой \code{play-services-auth}, в которой есть \code{SignInIntent} (если огрубить, то это всплывающий экран, на котором пользователю предлагается выбрать аккаунт для авторизации в один клик), из результата которого можно достать код авторизации.
    \end{itemize}

    Получается следующая схема работы: \code{GoogleDriveAPI} принимает экземпляр интерфейса \code{GoogleAuthorizationRequester}, позволяющего ему при необходимости получать код доступа или обновлять его. На каждой платформе есть своя реализация этого интерфейса.

    При инициализации \code{GoogleDriveFS} можно указывать пространство\\ (scope), в котором приложение хочет работать (все файлы пользователя или приватная папка приложения).

    Благодаря мультиплатформенности библиотеки Ktor, весь код для совершения запросов и управления файлами на логическом уровне полностью переиспользуется (около 650 строк кода), платформо-специфичные компоненты сравнительно небольшие и занимают на платформах JS (browser) и Android около 50 строк кода и около 100 на JVM.
  % subsubsection
  \subsubsection{\code{SqliteFS}}
    \todo{адаптер к Sqlite на Андроиде}
  % subsubsection

% subsection

\subsection{Используемые зависимости}

  \subsubsection{Ktor}\label{dependencies-ktor}
    \todo{нужен как мультиплатформенный HTTP-клиент + из IO взял ByteChannel}
  % subsubsection

  \subsubsection{Зависимости на платформе Android}
    \begin{itemize}
      \item activity-ktx
        \todo{предоставляет расширения java классов для языка котлин??}
      \item play-services-auth
        \todo{тут лежит SignInIntent чтобы авторизацию производить}
    \end{itemize}
  % subsubsection

% subsection

% section
