\section{Презентация решения}

В данной главе дан высокоуровневый обзор реализованной библиотеки \code{multifs}\cite{gh-multifs}, а также обоснования принятых архитектурных решений.

\subsection{Архитектура библиотеки}
  Ввиду того, что одна из главных задач заключается в организации поддержки файловых хранилищ на платформе JS (browser), то есть в веб-браузерах, возникает вопрос, какие файловые хранилища вообще можно на этой платформе поддержать? Поскольку в современных веб-браузерах много внимания уделяется безопасности, в них отсутствует доступ к файловой системе операционной системы, на которой они запущены. Для сохранения данных между сеансами можно пользоваться свойством \code{localStorage}\cite{dev-mozilla-localstorage} --- оно позволяет сохранять данные в виде пар ключ-значение. Гипотетически можно эмулировать файловую систему через эту структуру данных. Однако объем \code{localStorage} часто ограничен веб-браузерами и невелик: например, веб-браузер Firefox версии 98.0 ограничивает объем \code{localStorage} примерно десятью мегабайтами памяти. Если представить, что мы пишем, скажем, онлайн-редактор документов в формате docx и pdf, поддерживающее к тому же картинки, то сохранить много документов в таком хранилище просто не выйдет.

  Необходим доступ к <<настоящему>> файловому хранилищу, и в таком случае можно предложить следующие альтернативы локальной файловой системе, доступные из веб-браузеров:
  \begin{itemize}
    \item облачные хранилища, предоставляющие HTTP REST\cite{rest} API интерфейс для доступа к данным (Google Drive, Yandex.Disk, Dropbox, Amazon S3, и т.д.);
    \item подключение к удаленным файловым системам посредством FTP\cite{ftp}, как это сделано в проекте kile\cite{gh-kile}, или другим протоколам передачи файлов (SFTP, WebDAV, и т.д.).
  \end{itemize}

  Поскольку целью работы является также создание как можно более гибкой библиотеки в плане расширения множества поддерживаемых файловых хранилищ, имеет смысл выяснение функциональности и особенностей, которые имеют современные файловые хранилища.

  \subsubsection{Обзор функциональности и особенностей файловых хранилищ}\label{filesystems-overview}
    Для изучения выбраны несколько наиболее популярных онлайн-сервисов для хранения данных с публичным API: Google Drive, Яндекс.Диск, Dropbox, Amazon S3. Здесь перечисляются наиболее интересная (по мнению автора) функциональность и особенности, которые могут пригодится при решении поставленной задачи, более подробная информация содержится в официальной документации сервисов.
    
    \paragraph{Google Drive\cite{gdrive-about-files}.} 
      Файлы и папки не отличаются с точки зрения представления (то есть всё является файлом), различаются полем MimeType (у папок он равен \code{application/vnd.google-apps.folder}). Каждый файл имеет уникальный идентификатор (ID), при этом не запрещается иметь несколько файлов с одинаковым именем в одной папке. Файлы могут помимо своего содержимого хранить произвольные свойства (пары ключ-значение), есть атрибуты времени создания, модификации и доступа, атрибуты прав доступа. Файлы могут принадлежать одному из трёх изолированных пространств (spaces): пространство диска (drive space) --- основное пространство, в котором пользователь хранит свои файлы; пространство приложения (app data folder space) --- пространство, доступное только приложению и не доступное пользователю; пространство фотографий (photos space). Среди методов доступны создание файлов, скачивание, загрузка (в том числе больших файлов по частям), копирование (не папок), получение и изменение метаданных отдельно от содержимого (можно таким образом перемещать файлы), получение списка файлов с указанием фильтров (например, по id родителя).

    \paragraph{Яндекс.Диск\cite{yadisk-docs}.} Строгая иерархия каталогов и файлов, имена файлов уникальны и чувствительны к регистру. Доступна папка приложения, однако здесь пользователь имеет к ней прямой доступ. Файлы могут хранить произвольные атрибуты (пары ключ-значение). Присутствуют аналогичные методы для выполнения операций, перечисленных выше. Стоит отметить, что загрузка файлов на сервер по частям недоступна, а также доступно копирование папок. Файлы имеют одного владельца, но можно делать файлы полностью публичными.

    \paragraph{Dropbox\cite{dropbox-docs}.} Иерархия папок и файлов, имеющих уникальный идентификатор. Можно адресовать узлы как по пути от корня, так и по идентификаторам. Имена не чувствительны к регистру. Есть папки приложений. Поддерживаются произвольные атрибуты (пары ключ-значение). Доступна аналогичная функциональность как и у Яндекс.Диска, но доступна загрузка по частям. Есть система контроля доступа к файлам с разной гранулярностью (пользователи и группы).

    \paragraph{Amazon S3\cite{amazon-s3-docs}.} Данные хранятся в объектах (objects), расположенных в контейнерах (buckets). Объекты представляют собой содержимое файла и метаданные. Формально контейнер является плоской структурой (т.е. он хранит все объекты без иерархии), но можно организовать иерархию файлов и папок на логическом уровне, используя разделители (\code{/}) и общие префиксы для файлов, находящихся в одной директории. Есть система управления доступом к объектам, загрузка по частям, версионирование, произвольные атрибуты, копирование и другие методы, перечисленные выше.

    \paragraph{} Отдельно стоит отметить, что файловые системы наиболее популярных операционных систем для персональных компьютеров (Windows --- NTFS, FAT; дистрибутивы Linux --- ext4, btrfs, другие; Mac OS X --- APFS, HFS+) тоже имеют свои особенности. Например, файловая система HFS+ по умолчанию настроена так, что имена не чувствительны к регистру. В Windows по умолчанию операции с файловой системой осуществляются в не чувствительном к регистру режиме\cite{windows-case-sensitivity}. В дистрибутивах Linux файловые системы чувствительны к регистру. Данную особенность нужно учитывать при разработке приложений для этих платформ.

  %subsubsection
  \subsubsection{Исследование вариантов организации архитектуры \todo{поменять?}}
    Самое близкое к решению целевой задачи из уже существующего (в концептуальном смысле) --- это упомянутый в обзоре проект korio\cite{gh-korio}. В нем представлен базовый интерфейс виртуальной файловой системы как абстракции, которую должны реализовать все наследники на конкретных платформах. Однако этот интерфейс сильно перегружен: например, там есть методы для наблюдения за событиями файловой системы на определенном файле, но (в нашем случае) такую функциональность поддерживают не все облачные хранилища (например, Яндекс.Диск не поддерживает), также некоторые абстрактные методы имеют базовые реализации, которые ничего не делают (например, метод \code{touch}). При попытке поддержать конкретное файловое хранилище, может возникнуть ситуация, когда реализация части функциональности не будет возможна ввиду отсутствия такой функциональности у целевого хранилища. В результате, когда пользователь-разработчик будет пытаться использовать определенную функциональность виртуальной файловой системы в общем модуле мультиплатформенного проекта, у него не будет уверенности, что она вообще реализована.

    Каких дополнительных свойств хочется добиться от конечной библиотеки: 
    \begin{itemize}
    \item базовый интерфейс виртуальной файловой системы дает гарантию поддержки минимального набора операций, с помощью которого можно выполнять любые базовые операции над файлами (создание, удаление файлов и папок; запись, чтение, перемещение, копирование файлов) --- это позволит быстро обеспечивать базовую поддержку любых хранилищ, которая нужна пользователю;
    \item поддержка особых возможностей обеспечивается через реализацию дополнительных интерфейсов-расширений виртуальной файловой системы.
    \end{itemize}
    Понятно, что для приложения может быть недостаточно лишь базовых операций для работы с файлами. Нужен инструмент для определения контракта по необходимой функциональности конкретных файловых хранилищ, которые будут использоваться на целевых платформах. Для решения этой проблемы предлагается использовать мощь системы типов языка Kotlin, об этом будет рассказано позже.

    Ввиду особенностей различных файловых хранилищ, перечисленных в разделе \ref{filesystems-overview}, предлагается отказаться от адресации узлов по полным путям и ввести на уровне типов отдельно папку и файл как узлы иерархии.

    \todo{что-то ещё?}
    \todo{про симлинки?}
  % subsubsection

  \subsubsection{\code{VFS}}
    % Основа для любой FS, 
    % Устройство VFS, VFSNode, File, Folder.
    % Generic интерфейс

    \makefig{vfsnode-folder-file}{0.65\textwidth}{
      \label{fig:vfsnode-folder-file} Интерфейсы узлов виртуальной файловой системы.
    }
    Ссылаемся на график~\ref{fig:vfsnode-folder-file}.

    \makefig{vfs}{0.8\textwidth}{
      \label{fig:vfs} Интерфейс виртуальной файловой системы.
    }
    Ссылаемся на график~\ref{fig:vfs}.
  % subsubsection

  \subsubsection{Инварианты и гарантии}
    \todo{ссылка на родителя}  

    \todo{exception'ы и их ловля, метки}

    \todo{если папка не пуста, удалить ее нельзя без recursively}
    
    \todo{нет ограничения на имена файлов папок и тд, за этим должен следить пользователь-разраб}
  % subsubsection

  \subsubsection{Преимущества и недостатки выбранного подхода}
    \todo{удобная и понятная навигация с выводом типов}

    \todo{интерфейс предоставляет только ту функциональность, которая на самом деле доступна}

    \todo{довольно емкий платформо-специфичный код (определение бекендов)}

    \todo{не очень удобно записывать ограничения на типы, но вот если котлин сделает типы-пересечения, то станет норм}

    \todo{без тайпкастов не обойтись}
    
  % subsubsection

% subsection

\subsection{Хранилища, поддержанные библиотекой}

  \subsubsection{\code{SystemFS}}
    \makefig{systemfs-detailed}{\textwidth}{
      \label{fig:systemfs-detailed}
          \todo{SystemFS}.
    }
    Ссылаемся на график~\ref{fig:systemfs-detailed}.
    \todo{обертка над \code{java.nio.Path}}
  % subsubsection
  \subsubsection{\code{GoogleDriveFS}}
    \todo{GoogleDriveAPI и сам GoogleDriveFS в общем коде, на платформах только Authorizer'ы}
    \makefig{gdrive-multiplatform-arch}{\textwidth}{
      \label{fig:gdrive-multiplatform-arch}
          Архитектура реализации поддержки файлового хранилища Google Drive.
    }
    Ссылаемся на график~\ref{fig:gdrive-multiplatform-arch}.
  % subsubsection
  \subsubsection{\code{SqliteFS}}
    \todo{адаптер к Sqlite на Андроиде}
  % subsubsection

% subsection

\subsection{Используемые зависимости}

  \subsubsection{Ktor}
    \todo{нужен как мультиплатформенный HTTP клиент + из IO взял ByteChannel}
  % subsubsection

  \subsubsection{Зависимости на платформе Android}
    \begin{itemize}
      \item activity-ktx
        \todo{предоставляет расширения java классов для языка котлин??}
      \item play-services-auth
        \todo{тут лежит SignInIntent чтобы авторизацию производить}
    \end{itemize}
  % subsubsection

% subsection

% section
