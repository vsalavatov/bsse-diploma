\section{Детали реализации} \label{solution-details}

\subsection{Структура проекта}
  \makefig{modules}{0.5\textwidth}{\label{fig:modules}
    Структура модулей проекта \code{multifs}.
  }
  
  Библиотека \code{multifs}\cite{gh-multifs} разделена на пять модулей, представленных на рисунке~\ref{fig:modules}. Модуль Common содержит определения базовых интерфейсов библиотеки, а также основную часть логики для поддержки Google Drive (\code{GoogleDriveAPI} и \code{GoogleDriveFS}). Модуль CommonJvmAndroid нужен для реализации поддержки \code{SystemFS}, так как необходимая для этого функциональность доступна на обеих платформах JVM и Android. Модули JVM и JS (browser) содержат реализации интерфейса \code{GoogleAuthorizationRequester}, обеспечивающих получение кода доступа к Google Drive пользователя. В модуле Android, помимо реализации этого интерфейса, содержится также реализация \code{SqliteFS}.
  
%subsection

\subsection{\code{GoogleDriveFS}}
  \subsubsection{\code{GoogleDriveAPI}}
    \code{GoogleDriveAPI} использует HTTP-клиент библиотеки Ktor с подключаемым модулем \code{Auth}, который самостоятельно обеспечивает добавление HTTP-заголовка \code{Bearer} с ключом доступа и при необходимости вызывает методы для получения или обновления этого ключа.

    Так как большинство реализованных методов по своей механике не сильно друг от друга отличаются, здесь будет дан обзор наиболее интересных из них. 

    \paragraph{Метод list.} В качестве аргумента принимает идентификатор папки, список детей которой необходимо получить. Совершает GET-запросы по адресу \code{https://www.googleapis.com/drive/v3/files} с дополнительным параметром для получения детей именно указанной папки, в теле ответа возвращается список файлов (возможно, частичный) с метаинформацией в виде JSON-документа. Если в теле ответа указано поле \code{nextPageToken}, то полученный список не является полным и выполняются дополнительные запросы, чтобы получить следующие части ответа. Тело ответа десериализуется в JSON-объект с помощью библиотеки \code{kotlinx.serialization.json}.

    \paragraph{Метод download.} В качестве аргумента принимает идентификатор файла, который необходимо скачать. Выполняет GET-запрос по адресу\\ \code{https://www.googleapis.com/drive/v3/files/\$id} с параметром\\ \code{alt=media}, который обозначает опцию получения именно содержимого файла. Полностью считывается тело ответа, которое и является содержимым файла.

    \paragraph{Метод downloadStream.} Этот метод, в отличие от предыдущего, предназначен для получения содержимого файла в потоковом режиме. Для этого создается экземпляр \code{ByteChannel}, который возвращается из функции. В качестве побочного эффекта в области видимости сопрограмм (coroutine scope) HTTP-клиента запускается сопрограмма, которая выполняет запрос и копирует (потоково) тело ответа в ранее созданный канал. В случае исключения, канал закрывается с информацией о брошенном исключении. При завершении получения ответа канал закрывается.

    \paragraph{Метод upload.} В качестве аргументов принимает идентификатор файла и его содержимое в виде массива байт. Выполняется PATCH-запрос по адресу \code{https://www.googleapis.com/upload/drive/v3/files/\$id} с параметром \code{uploadType=media}, в теле которого записано полное содержимое фалйа.

    \paragraph{Метод uploadStream.} В качестве аргументов принимает идентификатор файла и \code{ByteReadChannel}, из которого можно вычитать содержимое файла. Сначала выполняется аналогичный PATCH-запрос для получения адреса возобновляемой загрузки данных (в данном случае значение параметра \code{uploadType=resumable}), по которму можно загружать содержимое файла частями. Сервис Google Drive налагает ограничение на размер загружаемых частей: размеры всех частей, кроме завершающей, должны быть кратны 256 КиБ. Алгоритм загрузки следующий. Вычитываются 256 КиБ данных из входного канала (либо меньше, если канал закрылся). Полученный кусок (chunk) загружается по полученному адресу с помощью метода PUT и заголовка \code{Content-Range}, который содержит местоположение этих данных в файле. В случае ошибок выполняется повторный запрос с промежутком в 250 мс, в случае успеха счетчик повторных запросов сбрасывается, а при превышении порогового значения (4 попытки) бросается исключение. Данная процедура повторяется, пока не будут загружены все данные из входного канала.

    Реализованный алгоритм нельзя назвать оптимальным, поскольку, во-первых, можно вычитывать следующий кусок данных, пока предыдущий загружается, во-вторых, можно масштабировать размер отправляемых данных для лучшей утилизации пропускной способности, но для этого нужно реализовать соответствующий механизм, который будет подстраиваться под качество интернет-соединения.

  %subsubsection
  \subsubsection{\code{GoogleAuthorizationRequester} и его реализации}\label{solution-details-gdrive-auth-req}
    Как обсуждалось в разделе~\ref{solution-google-drive-fs}, процесс получения авторизации к Google Drive пользователя реализуется по-разному на каждой из платформ.

    \paragraph{JVM.} На платформе JVM доступен класс\\ \code{HttpCallbackGoogleAuthorizationRequester}. Метод\\ \code{requestAuthorization} реализован следующим образом. Создается переменная \code{tokensFuture} типа \code{CompletableDeferred<GoogleAuthTokens>}, в которую будут записаны ключи доступа. Запускается HTTP-сервер на случайном порте, ожидающий HTTP-запрос кодом авторизации. Далее с помощью системных средств открывается страница в веб-браузере со специально сформированным адресом сервиса авторизации Google, где пользователю предлагается выбрать свой аккаунт и подтвердить выдачу авторизации. После получения разрешения, веб-страница посылает запрос с кодом авторизации на адрес запущенного HTTP-сервера. Получив код авторизации, выполняется HTTP-запрос для его обмена на ключ доступа, после чего полученные ключи записываются в переменную \code{tokensFuture}. После того как пользователь направлен в веб-браузер, выполняется ожидание результата на переменной \code{tokensFuture}. После этого запущенный HTTP-сервер останавливается и результат в виде полученных ключей возвращается.

    \paragraph{Android.} На платформе Android доступен класс\\ \code{IntentGoogleAuthorizationRequester}. Для получения кода авторизации используются средства библиотеки \code{play-services-auth}. Данный класс в конструкторе принимает, кроме учетных данных приложения и пространства (scope) Google Drive, ещё контекст Android-приложения и лямбда-функцию типа \code{suspend (Intent) -> ActivityResult}. Задача этой лямбда-функции --- запустить переданный \code{Intent} (намерение) и вернуть после завершения его результат. Ввиду особенностей платформы Android, данную процедуру нельзя выполнить, не затрагивая код самого приложения (во всяком случае автору такие способы не известны). Однако, как показано в примерах, при использовании современной библиотеки Compose, можно реализовать эту функцию, не затрагивая существующий код.

    В данном классе при инициализации создается объект типа\\ \code{GoogleSignInClient}, который содержит \code{Intent} получения авторизации. При вызове метода \code{requestAuthorization} происходит запуск данного намерения через упомянутую лямбда-функцию. Со стороны пользователя это выглядит как всплывающее окно со списком учетных записей. После клика по одному из них окно закрывается, а результат передается для обработки в наш метод. Далее из результата достается код авторизации, который меняется на ключ доступа.

    Полученные ключи доступа, ввиду требований безопасности, имеют срок годности порядка одного часа, из-за чего их необходимо периодически обновлять. Для этого выполняется HTTP-запрос по адресу\\ \code{https://oauth2.googleapis.com/token}, параметризованный ключом обновления (refresh token). Поскольку данная процедура общая для реализаций JVM и Android, она вынесена в Companion Object интерфейса\\ \code{GoogleAuthorizationRequester}. При неуспешном обновлении ключа доступа, вызывается \code{requestAuthorization} для получения нового ключа.
    
    \paragraph{JS (browser).} Для браузерных приложений доступен класс\\ \code{PopupGoogleAuthorizationRequester}. Для его работы отдельно требуется, чтобы html-страница приложения загружала Google Platform Library\footnote{к сожалению, слишком поздно выяснилось, что эта библиотека объявлена устаревшей и перестанет работать в конце марта 2023 года, однако заменить её в будущем на новую библиотеку Sign In With Google не должно составить большого труда}, доступную по адресу \code{https://apis.google.com/js/platform.js}, а также инициализировала её модуль \code{gapi.auth2} с помощью идентификатора используемого приложения. 

    Реализация метода \code{requestAuthorization} представляет из себя вызов метода \code{signIn} на объекте, который порождается упомянутой библиотекой. Этот метод возвращает \code{Promise}-объект\cite{js-promise}, результатом которого является объект с информацией об учетной записи, содержащей также и код доступа. При вызове метода \code{signIn} открывается всплывающее окно с предложением выбрать учетную запись для доступа к Google Drive. После выбора учетной записи, окно закрывается, а результат завершает созданный \code{Promise}.

    Обновление ключа доступа происходит аналогично через вызов метода \code{reloadAuthResponse} на полученном ранее объекте  учетной записи пользователя.
  %subsubsection
%subsection

\subsection{\code{SqliteFS}}
  Для того, чтобы сэмулировать иерархическую структуру ВФС, в базе данных SQLite создаются две таблицы: папки и файлы. Таблица папок имеет поля идентификатора (первичный ключ с автоинкрементом), имени и ссылки на родительскую папку. Таблица файлов устроена аналогично, но дополнительно имеет поле содержимого файла типа \code{blob}. 

  Эти таблицы создаются с ограничением уникальности пары\\ \code{(name, parent)}, что обеспечивает существование не более одной папки или файла с выбранным именем внутри родительской папки.
  Также добавлено ограничение на ненулевую длину имени узла, которое не распространяется на корневую папку. Корневая папка добавляется отдельно после создания таблицы и имеет идентификатор $0$ и пустое имя.
  
  Описание таблиц и команды их создания вынесены в отдельный объект в файле \code{SQLContract.kt}.

  Конструктор \code{SqliteFS} принимает в качестве единственного аргумента экземпляр класса \code{SqliteFSDatabaseHelper}, являющегося наследником класса \code{SQLiteOpenHelper}, в котором переопределены методы для первоначального создания таблиц в базе данных. Данный класс наследует свойства \code{writableDatabase} и \code{readableDatabase}, которые уже представляют экземпляры класса \code{SQLiteDatabase}, имеющего методы для совершения самих SQL-запросов.

  Сами запросы не представляют большого интереса, для примера прилагается самый сложный запрос из реализации метода \code{copy}:
  \begin{minted}[fontsize=\small]{kotlin}
db.execSQL(
  """
    INSERT INTO ${Files.TABLE_NAME} 
      (${Files.COLUMN_NAME}, ${Files.COLUMN_PARENT}, ${Files.COLUMN_DATA})
    SELECT 
      ? ${Files.COLUMN_NAME},
      ${newParent.id} ${Files.COLUMN_PARENT},
      ${Files.COLUMN_DATA}
    FROM ${Files.TABLE_NAME}
    WHERE ${Files.COLUMN_ID} = ${file.id};
  """.trimIndent(),
  arrayOf(targetName)
)    
  \end{minted}
%subsection

\subsection{Тестирование}
  Автоматические тесты реализованы только для ВФС \code{SystemFS}, проверяются в основном лишь базовые сценарии. Всего написано 7 тестов. Встроенное в среду разработки IntelliJ IDEA CE средство подсчета покрытия кода показывает 53\% покрытие по методам и 34\% покрытие по строкам в модуле \code{dev.salavatov.multifs.systemfs}.

  Корректность работы реализованной библиотеки проверялась в ручном режиме через реализованные на ее базе приложения, о которых рассказывается в разделе~\ref{usage-examples}.
%subsection

\subsection{Прочее}
  \paragraph{Обобщенные реализации методов \code{move} и \code{copy}.} Как было упомянуто в разделе~\ref{lib-arch-basic-interfaces}, семантика методов \code{move} и \code{copy} предполагает, что в случае несоотвествия типа переданного в метод файла типу файла самой ВФС, операция выполняется, однако, возможно, с чтением содержимого в память полностью. Данное поведение является общим для всех реализаций ВФС, поэтому оно выделено в отдельные встраиваемые (inline) обобщенные методы \code{genericCopy} и \code{genericMove} с параметрами вещественного (reified) типа\cite{kotlin-reified} \code{FileClass} и \code{FolderClass}. Reified-параметры нужны, поскольку в JVM не сохраняется информация о типовых параметрах.

%subsection

% section
